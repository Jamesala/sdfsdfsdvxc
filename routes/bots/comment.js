const express = require('express');
const router = express.Router();
const crypto = require('crypto');
const moment = require('moment');
const botsdata = require("../../database/models/bots/bots.js");

console.success("[Bots] /bots/comment.js router loaded.".brightYellow);

// Rate limiting map
const ratelimitMap = new Map();

// Error function
function error(res, message) {
    return res.json({ error: true, message: message });
}

// Profanity filter list (can be expanded)
const bannedWords = [
    // Polish bad words
    'kurwa', 'chuj', 'jebany', 'pierdol', 'pierdole', 'pierdal', 'pierdolony',
    'pierdoliƒá', 'jebaƒá', 'jebie', 'jebiƒÖcy', 'jebana', 'jebany', 'jebane',
    'jebani', 'jebanka', 'jebanko', 'jebanku', 'jebankiem', 'jebankach',
    '.gg', 'discordzik.pl', 'czarny', 'murzyn',
    // English bad words
    'fuck', 'shit', 'bitch', 'asshole', 'cunt', 'dick', 'pussy', 'whore',
    'motherfucker', 'cock', 'bastard', 'slut', 'douche', 'fag', 'faggot'
];

// Function to check for profanity
function containsProfanity(text) {
    const lowerText = text.toLowerCase();
    return bannedWords.some(word => lowerText.includes(word.toLowerCase()));
}

router.post("/bots/comment", async (req, res) => {
    try {
        // Ensure the user is authenticated
        if (!req.user) {
            return res.render("404.ejs", {
                bot: global.client || null,
                path: req.path,
                user: req.isAuthenticated() ? req.user : null,
                req: req,
                message: "Aby m√≥c komentowaƒá bota, musisz siƒô zalogowaƒá."
            });
        }

        // Rate limiting based on IP
        const ip = req.cf_ip;
        const ratelimit = ratelimitMap.get(ip);
        if (ratelimit && ((ratelimit + 5000) > Date.now())) {
            return error(res, 'OsiƒÖgnƒÖ≈Çe≈õ limit szybko≈õci! Spr√≥buj ponownie za kilka sekund.');
        }
        ratelimitMap.set(ip, Date.now());

        // Destructure and validate request body
        let { botID, comment, stars } = req.body;

        if (typeof comment !== "string" || comment.trim().length === 0) {
            return error(res, "Proszƒô podaƒá prawid≈Çowy komentarz.");
        }
        if (typeof stars !== "string" || !/^[1-5]$/.test(stars)) {
            return error(res, "Proszƒô podaƒá prawid≈ÇowƒÖ ocenƒô gwiazdkowƒÖ (1-5).");
        }
        if (comment.length > 100) {
            return error(res, "Tw√≥j komentarz jest za d≈Çugi. Upewnij siƒô, ≈ºe ma mniej ni≈º 100 znak√≥w.");
        }

        // Fetch bot data
        const botdata = await botsdata.findOne({ botID });
        if (!botdata) {
            return res.render("404.ejs", {
                bot: global.client || null,
                path: req.path,
                user: req.isAuthenticated() ? req.user : null,
                req: req,
                message: "Bot, kt√≥rego szukasz nie istnieje."
            });
        }

        // Prevent self-commenting
        if (botdata.ownerID === req.user.id || botdata.coowners.includes(req.user.id)) {
            return error(res, "Nie mo≈ºesz komentowaƒá w≈Çasnego bota.");
        }

        // Check if user has already rated the bot
        if (botdata.rates?.some(rate => rate.author === req.user.id)) {
            return error(res, "Ju≈º oceni≈Çe≈õ tego bota.");
        }

        // Add new comment
        const comment_id = crypto.randomBytes(16).toString("hex");
        await botsdata.updateOne(
            { botID },
            {
                $push: {
                    rates: {
                        author: req.user.id,
                        star_rate: stars,
                        message: comment.trim(),
                        id: comment_id,
                        date: Date.now()
                    }
                }
            },
            { upsert: true }
        );

        // Logowanie komentarza do kana≈Çu "komlog" TYLKO je≈õli ocena jest wiƒôksza ni≈º 0
        if (stars !== '0' && global.client && global.config.server.channels.komlog) {
            try {
                const channel = global.client.channels.cache.get(global.config.server.channels.komlog);
                if (channel) {
                    channel.send({
                        content: ` \`üìì\` Nowy komentarz do [Bota](https://discordzik.pl/bot/${botdata.botID}) dodany przez ${req.user.id}:
\n\`üåü\` Ocena: ${stars}
\n\`üí¨\` Komentarz: ${comment}`
                    });
                }
            } catch (error) {
                console.error('B≈ÇƒÖd podczas logowania komentarza:', error);
            }
        }

        // Respond with success
        return res.json({
            error: false,
            author: req.user.id,
            star_rate: stars,
            id: comment_id,
            stars: [1, 2, 3, 4, 5],
            message: "Komentarz dodano pomy≈õlnie."
        });

    } catch (error) {
        console.error(error.stack);
        return error(res, "WystƒÖpi≈Ç b≈ÇƒÖd. Spr√≥buj ponownie p√≥≈∫niej. Administratorzy zostali powiadomieni.");
    }
});

// Reply to a comment
router.post("/bots/comment/reply", async (req, res) => {
    try {
        if (!req.user) {
            return res.status(401).json({ error: true, message: "Musisz siƒô zalogowaƒá, aby odpowiadaƒá na komentarze." });
        }

        const { commentId, botID, message } = req.body;
        
        if (!commentId || !message || !botID) {
            return res.status(400).json({ error: true, message: "BrakujƒÖce wymagane pola." });
        }

        // Check for profanity in reply
        if (containsProfanity(message)) {
            return res.status(400).json({ 
                error: true, 
                message: "Twoja odpowied≈∫ zawiera niedozwolonƒÖ tre≈õƒá. Prosimy o kulturalne wyra≈ºanie siƒô." 
            });
        }

        const botdata = await botsdata.findOne({ botID: botID });

        if (!botdata) {
            return res.status(404).json({ error: true, message: "Nie znaleziono bota." });
        }

        const commentIndex = botdata.rates.findIndex(rate => rate.id === commentId);
        if (commentIndex === -1) {
            return res.status(404).json({ error: true, message: "Nie znaleziono komentarza." });
        }

        // Pobierz pe≈Çne dane u≈ºytkownika
        let user;
        try {
            user = global.client ? await global.client.users.fetch(req.user.id) : {
                username: req.user.username,
                avatar: req.user.avatar,
                tag: req.user.username
            };
        } catch (error) {
            user = {
                username: req.user.username,
                avatar: req.user.avatar,
                tag: req.user.username
            };
        }

        const newReply = {
            author: req.user.id,
            authorName: user.username,
            authorAvatar: user.avatar,
            message: message,
            date: new Date()
        };

        botdata.rates[commentIndex].replies = botdata.rates[commentIndex].replies || [];
        botdata.rates[commentIndex].replies.push(newReply);

        await botdata.save();

        // Logowanie odpowiedzi do kana≈Çu "replylog"
        if (global.config.server.channels.replylog && global.client) {
            try {
                const comment = botdata.rates[commentIndex];
                const channel = global.client.channels.cache.get(global.config.server.channels.replylog);
                if (channel) {
                    channel.send({
                        content: `\`üí¨\` Nowa odpowied≈∫ do [komentarza](https://discordzik.pl/bot/${botID}#comment-${commentId}) na bocie (ID: ${botID}):
\n\`üë§\` Autor odpowiedzi: ${user.tag} (${req.user.id})
\n\`üìù\` Tre≈õƒá odpowiedzi: ${message}
\n\`üìå\` Oryginalny komentarz: ${comment.message.substring(0, 100)}${comment.message.length > 100 ? '...' : ''}`
                    });
                }
            } catch (error) {
                console.error('B≈ÇƒÖd podczas logowania odpowiedzi:', error);
            }
        }

        return res.json({
            error: false,
            message: "Odpowied≈∫ zosta≈Ça dodana pomy≈õlnie.",
            reply: newReply
        });
    } catch (error) {
        console.error(error);
        return res.status(500).json({ 
            error: true, 
            message: "WystƒÖpi≈Ç b≈ÇƒÖd podczas dodawania odpowiedzi." 
        });
    }
});

// Delete reply to comment
router.post("/bots/comment/reply/delete", async (req, res) => {
    try {
        if (!req.user) {
            return res.status(401).json({ 
                error: true, 
                message: "Musisz siƒô zalogowaƒá, aby usunƒÖƒá odpowiedzi." 
            });
        }

        const { botID, commentId, replyId } = req.body;
        
        if (!botID || !commentId || !replyId) {
            return res.status(400).json({ 
                error: true, 
                message: "BrakujƒÖce wymagane pola." 
            });
        }

        const botdata = await botsdata.findOne({ botID: botID });

        if (!botdata) {
            return res.status(404).json({ 
                error: true, 
                message: "Nie znaleziono bota." 
            });
        }

        const commentIndex = botdata.rates.findIndex(rate => rate.id === commentId);
        if (commentIndex === -1) {
            return res.status(404).json({ 
                error: true, 
                message: "Nie znaleziono komentarza." 
            });
        }

        const replyIndex = botdata.rates[commentIndex].replies.findIndex(
            reply => reply._id.toString() === replyId || reply.id === replyId
        );
        
        if (replyIndex === -1) {
            return res.status(404).json({ 
                error: true, 
                message: "Nie znaleziono odpowiedzi." 
            });
        }

        // Sprawd≈∫ czy u≈ºytkownik jest autorem odpowiedzi lub administratorem
        const reply = botdata.rates[commentIndex].replies[replyIndex];
        if (reply.author !== req.user.id && !req.user.admin) {
            return res.status(403).json({ 
                error: true, 
                message: "Nie masz uprawnie≈Ñ do usuniƒôcia tej odpowiedzi." 
            });
        }

        // Logowanie usuniƒôcia odpowiedzi do kana≈Çu "replylog"
        if (global.config.server.channels.replylog && global.client) {
            try {
                const user = await global.client.users.fetch(req.user.id).catch(() => ({ tag: req.user.username }));
                const comment = botdata.rates[commentIndex];
                const channel = global.client.channels.cache.get(global.config.server.channels.replylog);
                if (channel) {
                    channel.send({
                        content: `\`üóëÔ∏è\` Usuniƒôto odpowied≈∫ do [komentarza](https://discordzik.pl/bot/${botID}#comment-${commentId}) na bocie (ID: ${botID}):
\n\`üë§\` Autor odpowiedzi: ${reply.authorName} (${reply.author})
\n\`üõ†Ô∏è\` Usuniƒôto przez: ${user.tag} (${req.user.id})
\n\`üìù\` Tre≈õƒá usuniƒôtej odpowiedzi: ${reply.message.substring(0, 100)}${reply.message.length > 100 ? '...' : ''}
\n\`üìå\` Oryginalny komentarz: ${comment.message.substring(0, 100)}${comment.message.length > 100 ? '...' : ''}`
                    });
                }
            } catch (error) {
                console.error('B≈ÇƒÖd podczas logowania usuniƒôcia odpowiedzi:', error);
            }
        }

        // Usu≈Ñ odpowied≈∫
        botdata.rates[commentIndex].replies.splice(replyIndex, 1);
        await botdata.save();

        return res.json({
            error: false,
            message: "Odpowied≈∫ zosta≈Ça usuniƒôta pomy≈õlnie."
        });
    } catch (error) {
        console.error(error);
        return res.status(500).json({ 
            error: true, 
            message: "WystƒÖpi≈Ç b≈ÇƒÖd podczas usuwania odpowiedzi." 
        });
    }
});

module.exports = router;